package com.example.productivityorganizer.ui.viewmodels

import android.app.Application
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import com.example.productivityorganizer.data.ReminderWorker
import com.example.productivityorganizer.data.local.TaskDao
import com.example.productivityorganizer.data.model.Category
import com.example.productivityorganizer.data.model.Task
import com.example.productivityorganizer.data.remote.SupabaseManager
import com.example.productivityorganizer.domain.manager.AchievementManager
import com.example.productivityorganizer.utils.Constants
import dagger.hilt.android.lifecycle.HiltViewModel
import io.github.jan.supabase.auth.auth
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Order
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import java.text.SimpleDateFormat
import java.time.Instant
import java.util.Calendar
import java.util.Locale
import java.util.TimeZone
import java.util.concurrent.TimeUnit
import javax.inject.Inject

@kotlinx.serialization.Serializable
data class CategoryForInsert(val user_id: String, val name: String)

// Define Enums for Filtering and Sorting
enum class StatusFilterOption { ALL, COMPLETED, INCOMPLETE }
enum class SortByOption { DUE_DATE, PRIORITY, NONE } // IMPORTANCE, URGENCY removed
enum class SortOrderOption { ASCENDING, DESCENDING }
enum class TimeFilterOption { ALL, TODAY, UPCOMING, PAST_COMPLETED, OVERDUE } // OVERDUE остается

// Define a data class for inserting tasks, excluding fields generated by Supabase
@Serializable
data class TaskForUpdate(
    val title: String,
    val description: String? = null,
    val due_date: String? = null, // Дата (YYYY-MM-DD)
    @SerialName("priority_level") val priorityLevel: String,
    val category_id: String? = null,
    val reminder_option: String? = null,
    @SerialName("end_time") val endTime: Long? = null // Время (Unix timestamp)
)

@Serializable
data class TaskForInsert(
    val user_id: String,
    val title: String,
    val description: String? = null,
    val due_date: String? = null, // Дата (YYYY-MM-DD)
    @SerialName("priority_level") val priorityLevel: String = "Medium",
    val category_id: String? = null,
    val reminder_option: String? = null,
    @SerialName("end_time") val endTime: Long? = null // Время (Unix timestamp)
)

@Serializable
data class TaskCompletionUpdate(
    @SerialName("is_completed") val is_completed: Boolean,
    @SerialName("completed_at") val completed_at: String? // Nullable, так как может быть null при uncheck
)

sealed class TaskUIState {
    object Loading : TaskUIState()
    data class Success(val tasks: List<Task>) : TaskUIState()
    data class SuccessSingleTask(val task: Task) : TaskUIState()
    data class Error(val message: String) : TaskUIState()
    object Idle : TaskUIState()
}

sealed class CategoryUIState {
    object Loading : CategoryUIState()
    data class Success(val categories: List<Category>) : CategoryUIState()
    data class Error(val message: String) : CategoryUIState()
    object Idle : CategoryUIState()
}

@HiltViewModel
class TaskViewModel @Inject constructor(
    private val taskDao: TaskDao, // Injected TaskDao
    private val application: Application, // Injected Application
    private val achievementManager: AchievementManager
) : ViewModel() {

    private val _taskUIState = MutableStateFlow<TaskUIState>(TaskUIState.Idle)
    val taskUIState: StateFlow<TaskUIState> = _taskUIState.asStateFlow()

    private val _categoryUIState = MutableStateFlow<CategoryUIState>(CategoryUIState.Idle)
    val categoryUIState: StateFlow<CategoryUIState> = _categoryUIState.asStateFlow()

    private val _selectedTaskState = MutableStateFlow<TaskUIState>(TaskUIState.Idle)
    val selectedTaskState: StateFlow<TaskUIState> = _selectedTaskState.asStateFlow()

    // Properties for Selections
    private val _selectedCategoryId = MutableStateFlow<String?>(null)
    val selectedCategoryId: StateFlow<String?> = _selectedCategoryId.asStateFlow()

    private val _selectedStatusFilter = MutableStateFlow(StatusFilterOption.ALL)
    val selectedStatusFilter: StateFlow<StatusFilterOption> = _selectedStatusFilter.asStateFlow()

    private val _selectedSortBy = MutableStateFlow(SortByOption.NONE)
    val selectedSortBy: StateFlow<SortByOption> = _selectedSortBy.asStateFlow()

    private val _selectedSortOrder = MutableStateFlow(SortOrderOption.ASCENDING)
    val selectedSortOrder: StateFlow<SortOrderOption> = _selectedSortOrder.asStateFlow()

    private val _selectedTimeFilter = MutableStateFlow(TimeFilterOption.ALL)
    val selectedTimeFilter: StateFlow<TimeFilterOption> = _selectedTimeFilter.asStateFlow()

    // Reminder option state
    private val _selectedReminderOption = MutableStateFlow<String?>("None")
    val selectedReminderOption: StateFlow<String?> = _selectedReminderOption.asStateFlow()

    val importantUrgentTasks: StateFlow<List<Task>> =
        taskDao.getHighestPriorityTasks()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val importantNotUrgentTasks: StateFlow<List<Task>> =
        taskDao.getHighPriorityTasks()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val notImportantUrgentTasks: StateFlow<List<Task>> =
        taskDao.getMediumPriorityTasks()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    val notImportantNotUrgentTasks: StateFlow<List<Task>> =
        taskDao.getLowPriorityTasks()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    private val supabase = SupabaseManager.supabaseClient
    private val TAG = "TaskViewModel"

    private fun getCurrentIsoTimestamp(): String {
        return Instant.now().toString()
    }

    fun getTasks() {
        viewModelScope.launch {
            _taskUIState.value = TaskUIState.Loading
            try {
                val currentUserId = supabase.auth.currentSessionOrNull()?.user?.id
                if (currentUserId == null) {
                    _taskUIState.value = TaskUIState.Error("User not authenticated.")
                    Log.e(TAG, "Cannot get tasks: User not authenticated.")
                    return@launch
                }

                val categoryId = _selectedCategoryId.value
                val statusFilter = _selectedStatusFilter.value
                val sortBy = _selectedSortBy.value
                val sortOrder = _selectedSortOrder.value
                val timeFilter = _selectedTimeFilter.value
                Log.d(TAG, "Applying filters: Category='$categoryId', Status='$statusFilter', SortBy='$sortBy', SortOrder='$sortOrder', TimeFilter='$timeFilter'")

                // Форматтер для ISO 8601 с миллисекундами и смещением, всегда в UTC.
                // Это необходимо для точных запросов к TIMESTAMPTZ в Supabase.
                val isoDateTimeFormatterForSupabase = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX", Locale.US).apply {
                    timeZone = TimeZone.getTimeZone("UTC")
                }

                val query = supabase.postgrest.from("tasks")
                    .select {
                        filter {
                            eq("user_id", currentUserId)
                            categoryId?.let { eq("category_id", it) }

                            when (statusFilter) {
                                StatusFilterOption.COMPLETED -> eq("is_completed", true)
                                StatusFilterOption.INCOMPLETE -> eq("is_completed", false)
                                StatusFilterOption.ALL -> { /* No specific status filter */ }
                            }

                            // Time-based filtering logic
                            when (timeFilter) {
                                TimeFilterOption.TODAY -> {
                                    val now = Calendar.getInstance()
                                    val todayStartCal = Calendar.getInstance().apply {
                                        set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH), 0, 0, 0)
                                        set(Calendar.MILLISECOND, 0)
                                        timeZone = TimeZone.getTimeZone("UTC") // <--- ВАЖНО: Установить UTC для Calendar
                                    }
                                    val todayEndCal = Calendar.getInstance().apply {
                                        set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH), 23, 59, 59)
                                        set(Calendar.MILLISECOND, 999)
                                        timeZone = TimeZone.getTimeZone("UTC") // <--- ВАЖНО: Установить UTC для Calendar
                                    }

                                    // Фильтрация по диапазону due_date (TIMESTAMPTZ)
                                    gte("due_date", isoDateTimeFormatterForSupabase.format(todayStartCal.time))
                                    lte("due_date", isoDateTimeFormatterForSupabase.format(todayEndCal.time))

                                    // Дополнительно: не показывать выполненные, если не фильтр COMPLETED
                                    if (statusFilter != StatusFilterOption.COMPLETED) {
                                        eq("is_completed", false)
                                    }
                                }
                                TimeFilterOption.UPCOMING -> {
                                    val now = Calendar.getInstance()
                                    val todayEndCal = Calendar.getInstance().apply {
                                        set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH), 23, 59, 59)
                                        set(Calendar.MILLISECOND, 999)
                                        timeZone = TimeZone.getTimeZone("UTC") // <--- ВАЖНО: Установить UTC для Calendar
                                    }

                                    // due_date строго после конца сегодняшнего дня
                                    gt("due_date", isoDateTimeFormatterForSupabase.format(todayEndCal.time))
                                    if (statusFilter != StatusFilterOption.COMPLETED) {
                                        eq("is_completed", false)
                                    }
                                }
                                TimeFilterOption.PAST_COMPLETED -> {
                                    val now = Calendar.getInstance()
                                    val todayStartCal = Calendar.getInstance().apply {
                                        set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now.get(Calendar.DAY_OF_MONTH), 0, 0, 0)
                                        set(Calendar.MILLISECOND, 0)
                                        timeZone = TimeZone.getTimeZone("UTC") // <--- ВАЖНО: Установить UTC для Calendar
                                    }

                                    // due_date до начала сегодняшнего дня И задача выполнена
                                    lt("due_date", isoDateTimeFormatterForSupabase.format(todayStartCal.time))
                                    eq("is_completed", true)
                                }
                                TimeFilterOption.OVERDUE -> {
                                    val now = Calendar.getInstance().apply {
                                        timeZone = TimeZone.getTimeZone("UTC") // <--- ВАЖНО: Установить UTC для Calendar
                                    }

                                    // due_date до текущего момента И задача не выполнена
                                    lt("due_date", isoDateTimeFormatterForSupabase.format(now.time))
                                    eq("is_completed", false)
                                }
                                TimeFilterOption.ALL -> {
                                    // Без дополнительных фильтров по времени
                                }
                            }
                        }
                        // Сортировка на стороне БД только для DUE_DATE
                        if (sortBy == SortByOption.DUE_DATE) {
                            val supabaseOrder = if (sortOrder == SortOrderOption.ASCENDING) Order.ASCENDING else Order.DESCENDING
                            order("due_date", supabaseOrder) // <--- Используем "due_date"
                            order("end_time", supabaseOrder) // <--- Используем "end_time" для вторичной сортировки
                        }
                    }

                val tasks = query.decodeList<Task>() // Получаем список задач из Supabase

                // --- СОРТИРОВКА НА КЛИЕНТЕ для приоритета ---
                val sortedTasks = when (sortBy) {
                    SortByOption.PRIORITY -> {
                        val priorityOrderMap = mapOf(
                            "Highest" to 4,
                            "High" to 3,
                            "Medium" to 2,
                            "Low" to 1
                        )
                        val comparator = compareBy<Task> {
                            priorityOrderMap[it.priorityLevel] ?: 0 // Если приоритет не найден, ставим его на 0
                        }
                        if (sortOrder == SortOrderOption.DESCENDING) { // От Highest к Low (4,3,2,1)
                            tasks.sortedWith(comparator.reversed())
                        } else { // От Low к Highest (1,2,3,4)
                            tasks.sortedWith(comparator)
                        }
                    }
                    else -> tasks // Для всех остальных видов сортировки, возвращаем как есть (уже отсортировано Supabase или по умолчанию)
                }

                _taskUIState.value = TaskUIState.Success(sortedTasks) // Обновляем StateFlow отсортированным списком

                taskDao.insertAll(sortedTasks) // Сохраняем в Room уже отсортированный список, если нужно
                Log.d(TAG, "Successfully fetched ${sortedTasks.size} tasks from Supabase and synchronized with Room. Sorted by: $sortBy")

            } catch (e: Exception) {
                _taskUIState.value = TaskUIState.Error("Failed to fetch tasks: ${e.message}")
                Log.e(TAG, "Error fetching tasks: ", e)
            }
        }
    }

    fun updateTaskPriority(taskId: String, priorityLevel: String) {
        viewModelScope.launch {
            try {
                Log.d(TAG, "updateTaskPriority: Attempting to update priority for task ID: $taskId to $priorityLevel in Room.")
                taskDao.updateTaskPriorityLevel(taskId, priorityLevel)

                val updateData = mapOf(
                    "priority_level" to priorityLevel
                )
                Log.d(TAG, "updateTaskPriority: Sending update to Supabase for task ID: $taskId with data: $updateData")
                val response = supabase.postgrest.from("tasks")
                    .update(updateData) {
                        filter {
                            eq("id", taskId)
                        }
                        select() // <--- УБЕДИТЕСЬ, ЧТО ЭТОТ select() ЕСТЬ!
                    }
                Log.d(TAG, "updateTaskPriority: Supabase update response for ID $taskId: ${response.data}") // Логируем ответ Supabase
                Log.d(TAG, "updateTaskPriority: Priority_level updated in Supabase for task ID: $taskId.")
                //getTasks() // <--- Добавим getTasks() сюда, чтобы обновить HomeScreen
            } catch (e: Exception) {
                Log.e(TAG, "updateTaskPriority: Error updating priority for task ID $taskId: ", e)
                // Опционально: можно показать Snackbar пользователю об ошибке
            }
        }
    }

    fun addTask(
        title: String,
        description: String?,
        dueDate: String?, // "YYYY-MM-DD"
        priorityLevel: String,
        categoryId: String? = null,
        reminderOption: String? = null,
        endTime: Long? = null // Unix timestamp for specific time on dueDate
    ) {
        viewModelScope.launch {
            _selectedReminderOption.value = reminderOption // Update local state for reminder
            try {
                val currentUserId = supabase.auth.currentSessionOrNull()?.user?.id
                if (currentUserId == null) {
                    _taskUIState.value = TaskUIState.Error("User not authenticated. Cannot add task.")
                    Log.e(TAG, "Cannot add task: User not authenticated.")
                    return@launch
                }

                val taskToInsert = TaskForInsert(
                    user_id = currentUserId,
                    title = title,
                    description = description,
                    due_date = dueDate,
                    priorityLevel = priorityLevel,
                    category_id = categoryId,
                    reminder_option = reminderOption,
                    endTime = endTime // Pass endTime
                )

                Log.d(TAG, "Attempting to insert task: $taskToInsert")
                // ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем .select() к insert
                val insertedTask = supabase.postgrest.from("tasks").insert(taskToInsert) {
                    select() // <--- ЭТА СТРОКА ГОВОРИТ SUPABASE ВЕРНУТЬ ВСТАВЛЕННЫЕ ДАННЫЕ
                }.decodeList<Task>().first() // <--- decodeList<Task>() ожидает массив
                Log.d(TAG, "Task insertion successful: ${insertedTask.id}. Refreshing tasks.")

                try {
                    taskDao.insertOrUpdateTask(insertedTask)
                    Log.d(TAG, "Newly added task ID: ${insertedTask.id} also saved to Room.")
                } catch (e: Exception) {
                    Log.e(TAG, "Error saving newly added task ${insertedTask.id} to Room: ", e)
                }

                // Schedule reminder based on insertedTask (which now has potential endTime)
                scheduleTaskReminder(insertedTask)

                // getTasks()

            } catch (e: Exception) {
                Log.e(TAG, "Error adding task: ", e)
                _taskUIState.value = TaskUIState.Error("Failed to add task: ${e.message}")
            }
        }
    }

    fun getTaskById(taskId: String) {
        viewModelScope.launch {
            _selectedTaskState.value = TaskUIState.Loading
            try {
                Log.d(TAG, "Fetching task with ID: $taskId")
                val response = supabase.postgrest.from("tasks")
                    .select {
                        filter {
                            eq("id", taskId)
                        }
                        single()
                    }
                val task = response.decodeAs<Task>()
                _selectedTaskState.value = TaskUIState.SuccessSingleTask(task)
                _selectedReminderOption.value = task.reminder_option ?: "None"
                Log.d(TAG, "Successfully fetched task: ${task.title} with reminder option: ${task.reminder_option}. DueDate: ${task.dueDate}, EndTime: ${task.endTime}")
            } catch (e: Exception) {
                _selectedTaskState.value = TaskUIState.Error("Failed to fetch task $taskId: ${e.message}")
                Log.e(TAG, "Error fetching task by ID $taskId: ", e)
            }
        }
    }

    fun updateTask(taskId: String, updatedTaskData: TaskForUpdate) {
        viewModelScope.launch {
            _selectedReminderOption.value = updatedTaskData.reminder_option
            try {
                Log.d(TAG, "updateTask: Attempting to update task ID: $taskId with data: $updatedTaskData")
                val updateResponse = supabase.postgrest.from("tasks")
                    .update(updatedTaskData) {
                        filter {
                            eq("id", taskId)
                        }
                        select() // <--- УБЕДИТЕСЬ, ЧТО ЭТОТ select() ЕСТЬ! (для возврата данных)
                    }
                Log.d(TAG, "updateTask: Supabase update successful for ID: $taskId. Response data: ${updateResponse.data}")

                try {
                    cancelTaskReminder(taskId)

                    // <--- ПРОВЕРЬТЕ ЭТОТ БЛОК! ---
                    // Возможно, updatedTaskFromDb не получает актуальные данные, если в Supabase что-то не так.
                    // Или проблема с decodeSingle().
                    val updatedTaskFromDb = supabase.postgrest.from("tasks")
                        .select { filter { eq("id", taskId) } }
                        .decodeSingle<Task>() // <--- Эта строка должна получить актуальную задачу из Supabase
                    Log.d(TAG, "updateTask: Fetched updated task from Supabase: ${updatedTaskFromDb.priorityLevel} (ID: $taskId)")

                    try {
                        taskDao.insertOrUpdateTask(updatedTaskFromDb)
                        Log.d(TAG, "updateTask: Task ID: ${updatedTaskFromDb.id} also updated in Room after general update. New priority in Room: ${updatedTaskFromDb.priorityLevel}")
                    } catch (e: Exception) {
                        Log.e(TAG, "updateTask: Error saving updated task ${updatedTaskFromDb.id} to Room: ", e)
                    }

                    scheduleTaskReminder(updatedTaskFromDb)

                } catch (e: Exception) {
                    Log.e(TAG, "updateTask: Error in post-update operations (fetching, Room update, reminder): ", e)
                }

                // getTasks() // <--- Обновляем список задач на HomeScreen

            } catch (e: Exception) {
                Log.e(TAG, "updateTask: Error updating task ID $taskId in Supabase: ", e)
                _taskUIState.value = TaskUIState.Error("Failed to update task: ${e.message}")
                // Опционально: можно показать Snackbar пользователю об ошибке
            }
        }
    }

    fun toggleTaskCompleted(taskId: String, isCompleted: Boolean) {
        viewModelScope.launch {
            try {
                Log.d(TAG, "Toggling task ID: $taskId to completed status: $isCompleted")

                val updateData = if (isCompleted) {
                    TaskCompletionUpdate(is_completed = true, completed_at = getCurrentIsoTimestamp())
                } else {
                    TaskCompletionUpdate(is_completed = false, completed_at = null)
                }

                supabase.postgrest.from("tasks")
                    .update(updateData) {
                        filter {
                            eq("id", taskId)
                        }
                    }
                Log.d(TAG, "Task completion status updated for ID: $taskId. Refreshing tasks.")

                try {
                    val updatedTaskFromSupabase = supabase.postgrest.from("tasks")
                        .select { filter { eq("id", taskId) } }
                        .decodeSingle<Task>()
                    taskDao.insertOrUpdateTask(updatedTaskFromSupabase)
                    Log.d(TAG, "Task ID: $taskId updated in Room. isCompleted: ${updatedTaskFromSupabase.isCompleted}")

                    if (updatedTaskFromSupabase.isCompleted) {
                        achievementManager.checkAndUnlockAchievements("")
                        cancelTaskReminder(taskId)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error refetching or saving task $taskId to Room after toggle: ", e)
                }

                getTasks()
            } catch (e: Exception) {
                Log.e(TAG, "Error toggling task completion for ID $taskId: ", e)
                _taskUIState.value = TaskUIState.Error("Failed to toggle task completion: ${e.message}")
            }
        }
    }

    fun deleteTask(taskId: String) {
        viewModelScope.launch {
            try {
                Log.d(TAG, "Attempting to delete task ID: $taskId")
                supabase.postgrest.from("tasks").delete {
                    filter {
                        eq("id", taskId)
                    }
                }
                Log.d(TAG, "Task deleted successfully: $taskId.")

                try {
                    taskDao.deleteTaskById(taskId)
                    Log.d(TAG, "Task ID: $taskId deleted from Room.")
                } catch (e: Exception) {
                    Log.e(TAG, "Error deleting task $taskId from Room: ", e)
                }

                cancelTaskReminder(taskId)

                Log.d(TAG, "Refreshing tasks after deletion.")
                getTasks()
            } catch (e: Exception) {
                Log.e(TAG, "Error deleting task ID $taskId: ", e)
                _taskUIState.value = TaskUIState.Error("Failed to delete task: ${e.message}")
            }
        }
    }

    fun fetchCategories() {
        viewModelScope.launch {
            _categoryUIState.value = CategoryUIState.Loading
            try {
                val currentUserId = supabase.auth.currentSessionOrNull()?.user?.id
                if (currentUserId == null) {
                    _categoryUIState.value = CategoryUIState.Error("User not authenticated.")
                    Log.e(TAG, "Cannot fetch categories: User not authenticated.")
                    return@launch
                }

                Log.d(TAG, "Fetching categories for user ID: $currentUserId")
                val response = supabase.postgrest.from("categories").select {
                    filter { eq("user_id", currentUserId) }
                }
                val categories = response.decodeList<Category>()
                _categoryUIState.value = CategoryUIState.Success(categories)
                Log.d(TAG, "Successfully fetched ${categories.size} categories.")

            } catch (e: Exception) {
                _categoryUIState.value = CategoryUIState.Error("Failed to fetch categories: ${e.message}")
                Log.e(TAG, "Error fetching categories: ", e)
            }
        }
    }

    fun addCategory(name: String) {
        viewModelScope.launch {
            _categoryUIState.value = CategoryUIState.Loading
            try {
                val currentUserId = supabase.auth.currentSessionOrNull()?.user?.id
                if (currentUserId == null) {
                    _categoryUIState.value = CategoryUIState.Error("User not authenticated. Cannot add category.")
                    Log.e(TAG, "Cannot add category: User not authenticated.")
                    return@launch
                }

                val categoryToInsert = CategoryForInsert(user_id = currentUserId, name = name)

                Log.d(TAG, "Attempting to insert category: $categoryToInsert")
                supabase.postgrest.from("categories").insert(categoryToInsert)
                Log.d(TAG, "Category insertion successful. Refreshing categories.")
                fetchCategories()

            } catch (e: Exception) {
                Log.e(TAG, "Error adding category: ", e)
                if (e.message?.contains("23505") == true || e.message?.contains("duplicate key value violates unique constraint") == true) {
                    _categoryUIState.value = CategoryUIState.Error("Category '$name' already exists.")
                    fetchCategories()
                } else {
                    _categoryUIState.value = CategoryUIState.Error("Failed to add category: ${e.message}")
                    fetchCategories()
                }
            }
        }
    }

    fun updateSelectedCategory(categoryId: String?) {
        _selectedCategoryId.value = categoryId
        getTasks()
    }

    fun updateStatusFilter(filter: StatusFilterOption) {
        _selectedStatusFilter.value = filter
        getTasks()
    }

    fun updateSortBy(sortBy: SortByOption) {
        _selectedSortBy.value = sortBy
        getTasks()
    }

    fun updateSortOrder(sortOrder: SortOrderOption) {
        _selectedSortOrder.value = sortOrder
        getTasks()
    }

    fun updateTimeFilter(filter: TimeFilterOption) {
        _selectedTimeFilter.value = filter
        getTasks() // Refresh tasks when filter changes
    }

    fun updateSelectedReminderOption(option: String?) {
        _selectedReminderOption.value = option
    }

    fun cancelTaskReminder(taskId: String) {
        val context = application.applicationContext
        try {
            WorkManager.getInstance(context).cancelUniqueWork(Constants.REMINDER_WORK_TAG_PREFIX + taskId)
            Log.d(TAG, "Attempted to cancel reminder for task ID: $taskId")
        } catch (e: Exception) {
            Log.e(TAG, "Error cancelling reminder for task ID $taskId: ", e)
        }
    }

    private fun scheduleTaskReminder(task: Task) {
        val context = application.applicationContext
        Log.d(TAG, "Attempting to schedule reminder for task: ${task.title} with ID: ${task.id}")

        val reminderOption = _selectedReminderOption.value

        // Напоминание имеет смысл только если есть dueDate и endTime, или хотя бы dueDate.
        // Если endTime не указано, напоминание будет на начало дня.
        if (task.dueDate == null || reminderOption == "None" || reminderOption == null) {
            Log.d(TAG, "No reminder to set for task '${task.title}'. Due date: ${task.dueDate}, Reminder option: $reminderOption. Cancelling any existing.")
            cancelTaskReminder(task.id)
            return
        }

        try {
            val dueDateOnlyFormatter = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
            // Создаем Calendar из dueDate
            val dueDateCalendar = Calendar.getInstance().apply {
                time = dueDateOnlyFormatter.parse(task.dueDate) ?: run {
                    Log.e(TAG, "Could not parse due date: ${task.dueDate}")
                    return
                }
                // Устанавливаем время на полночь, если endTime не указано
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }

            // Если есть endTime, устанавливаем его. endTime - это полный Unix timestamp.
            task.endTime?.let {
                dueDateCalendar.timeInMillis = it
            }

            val reminderTimeCalendar = dueDateCalendar.clone() as Calendar
            when (reminderOption) {
                "15 minutes before" -> reminderTimeCalendar.add(Calendar.MINUTE, -15)
                "1 hour before" -> reminderTimeCalendar.add(Calendar.HOUR_OF_DAY, -1)
                "1 day before" -> reminderTimeCalendar.add(Calendar.DAY_OF_MONTH, -1)
                else -> {
                    Log.d(TAG, "Unknown reminder option: $reminderOption. Not scheduling.")
                    return
                }
            }

            val currentTimeMillis = System.currentTimeMillis()
            val reminderTimeMillis = reminderTimeCalendar.timeInMillis
            val delayMillis = reminderTimeMillis - currentTimeMillis

            if (delayMillis <= 0) {
                Log.d(TAG, "Reminder time for task '${task.title}' is in the past ($delayMillis ms). Not scheduling.")
                return
            }

            val workerData = Data.Builder()
                .putString(Constants.TASK_ID_KEY, task.id)
                .putString(Constants.TASK_TITLE_KEY, task.title)
                .putString(Constants.TASK_DESC_KEY, task.description ?: "")
                .build()

            val workRequest = OneTimeWorkRequestBuilder<ReminderWorker>()
                .setInputData(workerData)
                .setInitialDelay(delayMillis, TimeUnit.MILLISECONDS)
                .addTag(Constants.REMINDER_WORK_TAG_PREFIX + task.id)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                Constants.REMINDER_WORK_TAG_PREFIX + task.id,
                ExistingWorkPolicy.REPLACE,
                workRequest
            )

            Log.d(TAG, "Successfully scheduled reminder for task '${task.title}' with delay ${delayMillis / 1000}s. WorkManager ID: ${workRequest.id}. Reminder Time (Local): ${SimpleDateFormat("dd MMM yyyy HH:mm", Locale.getDefault()).format(reminderTimeCalendar.time)}")

        } catch (e: Exception) {
            Log.e(TAG, "Error scheduling reminder for task ${task.title}: ", e)
        }
    }
}